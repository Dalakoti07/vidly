morgan middleware for logging each and every api call

app.get('env')=='developement' by default 

use debug package for app:startup and app:db debugging stuff

pug as templating engine

validate with joi module

always resutructue your code, make routes folder

always use Error('message') object when dealing with catch in promises because it prints call stack, i.e gives line number

Remember that aynchronous doesnot means multi-threaded, node is single thread but asynchronous

Promise.all()
Promise.race()

To write aynchronous code in JS we have theese 3 things: callback; promises (catch, then); and async wait (most used, and syntax is mostly like synchronous code, but uses promises concepts under the hood)

mongoose for having higher level of api communication with monogo database

comparison query operators in mongoose (>=,<=, in, not in,..etc), like to get course of price 15 dollar synatx would be 
    {'price':15}, but if we want to get courses whoses price is great than 15 dollar then we have {'price':{$gte: 15}}, where $gte is js operator
logical query operators in mongoose (or, and)

Note : mongoDb (no-sql) unlike postgres don't care about validation at document level (table level in sql), mongoose can help in validating the data before writing that data in mongoDb, use both joi and mongoose validation

Note : arrow function don't have this defined, so beaware of that

no sql and sql db is all about trade off bewteen performance and consistency

in mongoDb we don't have concept of transactions as in my sql database, it has two phase commit concept, u can use library called fawn which is will do 2 phase commit

there is a concept of unique id in sql, which auto increment, and thus it hurts scalability as we have to talk to central server when asking for unique identifier, i.e last id + 1
But in mongoDb, id is generated by driver and thus we dont need to depend upon on one central server , thus help in making highly scalable systems.

joi-objectId for validating id generated by mongo-driver for each document in mongoDb, and then this objectId can used as a valid datatype when string comes from request body, and can be validated by JOI module, like instead of Joi.String() we would have Joi.objectid()

lodash has lots of utility functions

use joi-password-complexity for enforcing strong passwords

bycrypt for encrptions

Node is single threaded, so always use asynchronous code so that u can serve other tasks if one task is taking too long.

give 400 bad request in wrong creds during login rather than 404, search why?

jsonwebtoken for tokens and iat, is used to determine age of jwt

send token back in response headers when registering (then immedialtely they can use that token if we want, or we can enforce users to login again even after registeration (maybe we want to verify their email and other stuff ) ), because 
token is not property of user thus, return token in header if you want to, and custom header are returned with 'x-' as prefix, 'x-auth-token'

Using -Expert Information Principle, we know that a module which has Expertise in Information should do the needful work, so here to generate jwt webtoken, which is being used in register and login both.
It (code ) Need to be refractored, one way is make another seprate  module and import that function in both login and register route.
Thus a better way to refractor this is to make generate token a method of userClass, bcoz generate token would take some of the properties (decoded payload) of user model and then would encrypt it, and take out meaningful key value pai necessarily.

To give authentication to some of the sensitive apis in our back-end we can make custom middlewares, which are like pipline, and thus each and every request to our apis, go through these middlewares, and in auth middleware we can obtain the payload from auth token, if valid token then we can do the needful

logout features just simply need deleting token from client end as token is in client side only, we have not stored it on server
Some people store auth token on db, but its a bad practise as if a hacker hack the db, then all token are exposed to hacker and then he/she can act like real user because of auth token, as auth token generally give access to protected apis
Always use https when sending data from client to server, when it contains auth token because, https secure than http 

Role based authorization - 401: unauthorized and 403 means forbidden

Now in route function we can provide middlewares in sequence which need to be executed (a particular sequence in which we want ), like we have done in delete movies where only admin can delete movies

We can use error middleware to catch all the erros and then if some error in dealing with api, we get some error then we pass next to the error middleware

Now we also don't want to bloter our code with repeated try and catch, thus make a asyncMiddleware which does async and wait call for us and does the try and catch stuff also, beatiful thing and some of the best lambda function used 

U can use express-async-erros so that we don't have to wrap each of our call from asyncMiddleware function, just import this and you dont have to wrap each api call with asyncMiddleware, just plain old async call, if this don't work in your project, u have to use above method 

Winston is a logging library (that handles all express error ), we can use process global along with winston to handle all uncaught exception in node server, but this works for synchronous code
For asynchronous code, where we have a Promise, we have same process of handling it but here we say that we are handling 'unhandledrejection' like we handleded 'uncaughtexception', now when such exceptions occur, its better to restart the process, as the process maybe in unclean state.
Winston can also catch express exceptions, like process.on('') listener does, and there is also 

Logging can be done both in files and as well as mongoDb, each of them have their own advantages and cons.

Resutructue the code such that moving all different sepration of concerns to startup folder, and into each .js file, and call these methods simply from index.js, bcoz we want to execute them as index.js is started

Jest as unit testing framework in api unit testing, jest by facebook, rewrite test script value to jest, so that jest find all the tests and execute them and show us the summary, and we can run npm test in terminal to trigger jest, its unit testing framework and it would be fine , u can write '--watchall' flag to do something like nodemon when testing

Note : '' is falsy in javascript


